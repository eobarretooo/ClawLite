<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ClawLite Control UI</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #060b1a;
      --bg-soft: #0b1228;
      --panel: #101a36;
      --panel-soft: #0d1731;
      --border: #233258;
      --text: #e7ecff;
      --muted: #9fb2de;
      --accent: #ff7a2f;
      --accent-soft: #ffb68e;
      --ok: #29c66f;
      --warn: #ffbf47;
      --err: #ff6170;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --shadow: 0 10px 32px rgba(0, 0, 0, 0.28);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: radial-gradient(circle at 20% -10%, #1d2f5e 0%, transparent 45%), var(--bg);
      color: var(--text);
      font-family: var(--sans);
    }

    #root {
      height: 100%;
    }

    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
      width: 100%;
    }

    .sidebar {
      background: linear-gradient(180deg, rgba(14, 23, 47, 0.96), rgba(9, 16, 35, 0.94));
      border-right: 1px solid var(--border);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      min-height: 100vh;
      overflow-y: auto;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border: 1px solid var(--border);
      background: rgba(16, 26, 54, 0.72);
      border-radius: 12px;
      box-shadow: var(--shadow);
    }

    .brand-badge {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: linear-gradient(135deg, #ff7a2f, #ff4e2c);
      display: grid;
      place-items: center;
      font-size: 16px;
      font-weight: 700;
      color: #fff;
    }

    .brand h1 {
      margin: 0;
      font-size: 15px;
      line-height: 1.2;
    }

    .brand p {
      margin: 2px 0 0;
      font-size: 11px;
      color: var(--muted);
    }

    .card {
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(16, 26, 54, 0.9), rgba(12, 22, 46, 0.86));
      border-radius: 12px;
      padding: 12px;
      box-shadow: var(--shadow);
    }

    .card h2,
    .card h3 {
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 6px;
    }

    input,
    textarea,
    select,
    button {
      font: inherit;
      color: inherit;
    }

    input,
    textarea,
    select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0a1230;
      padding: 10px;
      color: var(--text);
      outline: none;
    }

    textarea {
      min-height: 110px;
      resize: vertical;
      font-family: var(--mono);
      font-size: 12px;
    }

    input:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(255, 122, 47, 0.22);
    }

    .btn {
      border: 1px solid var(--border);
      background: #132249;
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      transition: 0.16s ease;
      white-space: nowrap;
    }

    .btn:hover {
      border-color: #3a5192;
      background: #182a59;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ff7a2f, #ff4e2c);
      border-color: rgba(255, 133, 74, 0.9);
      color: #fff;
      font-weight: 600;
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #ff8b45, #ff5f38);
    }

    .btn-danger {
      border-color: rgba(255, 97, 112, 0.5);
      color: #ffd2d7;
      background: rgba(141, 35, 54, 0.35);
    }

    .btn-success {
      border-color: rgba(41, 198, 111, 0.45);
      color: #c6ffe0;
      background: rgba(28, 110, 67, 0.3);
    }

    .auth-actions {
      display: flex;
      gap: 8px;
    }

    .status-list {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      color: var(--muted);
    }

    .status-value {
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
    }

    .status-ok {
      color: var(--ok);
    }

    .status-err {
      color: var(--err);
    }

    .nav {
      display: grid;
      gap: 6px;
    }

    .nav button {
      text-align: left;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: 0.16s ease;
    }

    .nav button:hover {
      border-color: var(--border);
      background: rgba(14, 25, 53, 0.72);
      color: var(--text);
    }

    .nav button.active {
      border-color: rgba(255, 122, 47, 0.5);
      background: rgba(255, 122, 47, 0.12);
      color: var(--accent-soft);
      font-weight: 600;
    }

    .main {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 18px;
      gap: 12px;
    }

    .main-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(12, 22, 48, 0.92);
      box-shadow: var(--shadow);
    }

    .main-title {
      margin: 0;
      font-size: 16px;
    }

    .main-subtitle {
      margin: 2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }

    .main-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .view {
      flex: 1;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      background: rgba(10, 20, 43, 0.92);
      overflow: auto;
      box-shadow: var(--shadow);
    }

    .grid {
      display: grid;
      gap: 12px;
    }

    .grid-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .grid-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .grid-4 {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .kpi {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(16, 27, 56, 0.88);
    }

    .kpi .k {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }

    .kpi .v {
      font-family: var(--mono);
      font-size: 20px;
      font-weight: 700;
    }

    .muted {
      color: var(--muted);
    }

    .mono {
      font-family: var(--mono);
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .row-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .stack {
      display: grid;
      gap: 8px;
    }

    .table-wrap {
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: auto;
      max-width: 100%;
      background: rgba(14, 24, 50, 0.82);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 620px;
      font-size: 12px;
    }

    th,
    td {
      text-align: left;
      border-bottom: 1px solid rgba(41, 61, 110, 0.6);
      padding: 8px;
      vertical-align: top;
    }

    th {
      color: var(--muted);
      font-weight: 600;
      background: rgba(10, 18, 38, 0.9);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 2px 8px;
      font-size: 11px;
      color: var(--muted);
      gap: 4px;
    }

    .badge.ok {
      border-color: rgba(41, 198, 111, 0.45);
      color: #b8ffd6;
      background: rgba(31, 103, 63, 0.35);
    }

    .badge.warn {
      border-color: rgba(255, 191, 71, 0.45);
      color: #ffe3a4;
      background: rgba(117, 86, 26, 0.3);
    }

    .badge.err {
      border-color: rgba(255, 97, 112, 0.45);
      color: #ffd6dc;
      background: rgba(119, 40, 56, 0.35);
    }

    .chat-box {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(11, 21, 45, 0.82);
      min-height: 340px;
      max-height: 55vh;
      overflow: auto;
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .chat-msg {
      max-width: 88%;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      white-space: pre-wrap;
      line-height: 1.4;
      border: 1px solid transparent;
    }

    .chat-msg.user {
      margin-left: auto;
      background: rgba(53, 93, 187, 0.36);
      border-color: rgba(77, 124, 237, 0.45);
    }

    .chat-msg.assistant {
      margin-right: auto;
      background: rgba(23, 86, 52, 0.34);
      border-color: rgba(46, 163, 99, 0.45);
    }

    .chat-msg.system {
      margin: 0 auto;
      background: rgba(123, 88, 30, 0.33);
      border-color: rgba(255, 191, 71, 0.42);
      color: #ffe3a4;
    }

    .chat-meta {
      font-size: 11px;
      margin-top: 4px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .editor {
      min-height: 320px;
      font-size: 12px;
      font-family: var(--mono);
    }

    .toast {
      position: fixed;
      right: 14px;
      bottom: 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      background: rgba(11, 21, 45, 0.96);
      color: var(--text);
      max-width: 360px;
      box-shadow: var(--shadow);
      z-index: 30;
    }

    .toast.ok {
      border-color: rgba(41, 198, 111, 0.52);
    }

    .toast.err {
      border-color: rgba(255, 97, 112, 0.52);
    }

    .empty {
      border: 1px dashed var(--border);
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      color: var(--muted);
    }

    @media (max-width: 1120px) {
      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        min-height: auto;
        border-right: 0;
        border-bottom: 1px solid var(--border);
      }

      .grid-4 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .grid-3 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 760px) {
      .main {
        padding: 10px;
      }

      .view {
        padding: 10px;
      }

      .grid-2,
      .grid-3,
      .grid-4 {
        grid-template-columns: 1fr;
      }

      .main-actions {
        width: 100%;
      }

      .main-actions .btn {
        flex: 1;
      }
    }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
  <div id="root"></div>
  <script type="text/babel">
    const {
      useState,
      useEffect,
      useMemo,
      useRef,
      useCallback,
    } = React;

    const TAB_DEFS = [
      { id: "overview", label: "Overview" },
      { id: "chat", label: "Chat" },
      { id: "sessions", label: "Sessions" },
      { id: "telemetry", label: "Telemetry" },
      { id: "channels", label: "Channels" },
      { id: "cron", label: "Cron" },
      { id: "config", label: "Config" },
      { id: "workspace", label: "Workspace" },
      { id: "skills", label: "Skills" },
      { id: "agents", label: "Agents" },
      { id: "logs", label: "Logs" },
      { id: "security", label: "Security" },
    ];

    const WORKSPACE_FILES = ["SOUL.md", "USER.md", "HEARTBEAT.md", "BOOTSTRAP.md"];

    function formatTime(ts) {
      if (!ts) return "-";
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return String(ts);
      return d.toLocaleString();
    }

    function formatUptime(totalSeconds) {
      if (typeof totalSeconds !== "number" || !Number.isFinite(totalSeconds)) return "-";
      const s = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const sec = s % 60;
      return `${h}h ${m}m ${sec}s`;
    }

    function clampText(value, max = 180) {
      const txt = String(value ?? "");
      if (txt.length <= max) return txt;
      return `${txt.slice(0, max - 1)}...`;
    }

    function prettyJSON(value) {
      try {
        return JSON.stringify(value, null, 2);
      } catch (_err) {
        return String(value ?? "");
      }
    }

    function parseHashToken() {
      try {
        const raw = window.location.hash.startsWith("#") ? window.location.hash.slice(1) : window.location.hash;
        const params = new URLSearchParams(raw);
        const t = (params.get("token") || "").trim();
        return t;
      } catch (_err) {
        return "";
      }
    }

    function normalizeError(err) {
      if (!err) return "unknown error";
      if (typeof err === "string") return err;
      if (err.message) return err.message;
      return String(err);
    }

    function Toast({ item, onClose }) {
      if (!item) return null;
      return (
        <div className={`toast ${item.kind || ""}`}>
          <div>{item.text}</div>
          <div className="row" style={{ justifyContent: "flex-end", marginTop: 8 }}>
            <button className="btn" onClick={onClose}>Close</button>
          </div>
        </div>
      );
    }

    function OverviewTab({ connected, apiCall }) {
      const [loading, setLoading] = useState(false);
      const [health, setHealth] = useState(null);
      const [bootstrap, setBootstrap] = useState(null);
      const [metrics, setMetrics] = useState(null);
      const [debugData, setDebugData] = useState(null);
      const [heartbeat, setHeartbeat] = useState(null);

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const [h, b, m, d, hb] = await Promise.all([
            fetch("/health").then((r) => r.json()),
            apiCall("/api/dashboard/bootstrap"),
            apiCall("/api/metrics"),
            apiCall("/api/dashboard/debug"),
            apiCall("/api/heartbeat/status"),
          ]);
          setHealth(h);
          setBootstrap(b);
          setMetrics(m);
          setDebugData(d.debug || null);
          setHeartbeat(hb);
        } catch (_err) {
          // Keep stale data on fetch failures.
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      if (!connected) {
        return <div className="empty">Connect to gateway to load overview metrics.</div>;
      }

      const status = bootstrap?.status || {};
      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Gateway Overview</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="grid grid-4">
            <div className="kpi">
              <div className="k">Status</div>
              <div className="v">{status.online ? "ONLINE" : "OFFLINE"}</div>
            </div>
            <div className="kpi">
              <div className="k">Model</div>
              <div className="v" style={{ fontSize: 14 }}>{status.model || "-"}</div>
            </div>
            <div className="kpi">
              <div className="k">Uptime</div>
              <div className="v" style={{ fontSize: 16 }}>{formatUptime(status.uptime_seconds || health?.uptime_seconds)}</div>
            </div>
            <div className="kpi">
              <div className="k">Connections</div>
              <div className="v">{status.connections ?? health?.connections ?? 0}</div>
            </div>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Runtime Metrics</h3>
              <div className="status-list">
                <div className="status-row"><span>Workers running</span><span className="status-value">{metrics?.workers?.running ?? 0}/{metrics?.workers?.total ?? 0}</span></div>
                <div className="status-row"><span>Tasks queued</span><span className="status-value">{metrics?.tasks?.queued ?? 0}</span></div>
                <div className="status-row"><span>Tasks running</span><span className="status-value">{metrics?.tasks?.running ?? 0}</span></div>
                <div className="status-row"><span>Log ring entries</span><span className="status-value">{metrics?.log_ring?.total ?? 0}</span></div>
                <div className="status-row"><span>Log errors</span><span className="status-value status-err">{metrics?.log_ring?.errors ?? 0}</span></div>
                <div className="status-row"><span>Log warnings</span><span className="status-value" style={{ color: "var(--warn)" }}>{metrics?.log_ring?.warnings ?? 0}</span></div>
                <div className="status-row"><span>Outbound sent OK</span><span className="status-value">{metrics?.channels_outbound?.totals?.sent_ok ?? 0}</span></div>
                <div className="status-row"><span>Outbound retries</span><span className="status-value">{metrics?.channels_outbound?.totals?.retry_count ?? 0}</span></div>
                <div className="status-row"><span>Outbound timeouts</span><span className="status-value">{metrics?.channels_outbound?.totals?.timeout_count ?? 0}</span></div>
                <div className="status-row"><span>Outbound fallbacks</span><span className="status-value">{metrics?.channels_outbound?.totals?.fallback_count ?? 0}</span></div>
                <div className="status-row"><span>Outbound failures</span><span className="status-value status-err">{metrics?.channels_outbound?.totals?.send_fail_count ?? 0}</span></div>
              </div>
            </div>

            <div className="card">
              <h3>Heartbeat</h3>
              <div className="status-list">
                <div className="status-row"><span>Last run</span><span className="status-value">{heartbeat?.last_run ? formatTime(heartbeat.last_run) : "-"}</span></div>
                <div className="status-row"><span>Last result</span><span className="status-value">{heartbeat?.last_result || "-"}</span></div>
                <div className="status-row"><span>Runs today</span><span className="status-value">{heartbeat?.runs_today ?? 0}</span></div>
                <div className="status-row"><span>Interval (s)</span><span className="status-value">{heartbeat?.interval_s ?? "-"}</span></div>
                <div className="status-row"><span>Next run in</span><span className="status-value">{heartbeat?.seconds_until_next ?? "-"}</span></div>
              </div>
            </div>
          </div>

          <div className="card">
            <h3>Debug Snapshot</h3>
            <div className="table-wrap">
              <table>
                <tbody>
                  <tr><th>Version</th><td className="mono">{debugData?.version || "-"}</td></tr>
                  <tr><th>Python</th><td className="mono">{debugData?.python || "-"}</td></tr>
                  <tr><th>Platform</th><td className="mono">{debugData?.platform || "-"}</td></tr>
                  <tr><th>Config dir</th><td className="mono">{debugData?.config_dir || "-"}</td></tr>
                  <tr><th>Skills dir</th><td className="mono">{debugData?.skills_dir || "-"}</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    }

    function ChatTab({ connected, token, apiCall, chatSessionId, setChatSessionId }) {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState("");
      const [wsState, setWsState] = useState("disconnected");
      const [streaming, setStreaming] = useState(false);
      const [lastMeta, setLastMeta] = useState(null);
      const wsRef = useRef(null);
      const activeMsgIdRef = useRef(null);
      const chatBoxRef = useRef(null);

      const appendMessage = useCallback((msg) => {
        setMessages((prev) => [...prev, msg]);
      }, []);

      const updateAssistantStream = useCallback((text, done, finalMeta) => {
        const msgId = activeMsgIdRef.current;
        if (!msgId) return;
        setMessages((prev) => prev.map((item) => {
          if (item.id !== msgId) return item;
          return {
            ...item,
            text,
            streaming: !done,
            meta: done ? (finalMeta || item.meta) : item.meta,
          };
        }));
      }, []);

      const loadHistory = useCallback(async () => {
        if (!connected || !chatSessionId) return;
        try {
          const data = await apiCall(`/api/dashboard/sessions/${encodeURIComponent(chatSessionId)}`);
          const rows = (data.messages || []).map((row, idx) => ({
            id: `hist-${idx}-${row.ts || ""}`,
            role: row.role === "assistant" ? "assistant" : "user",
            text: String(row.text || ""),
            ts: row.ts || "",
            streaming: false,
          }));
          setMessages(rows);
        } catch (_err) {
          // Ignore transient errors for history load.
        }
      }, [connected, apiCall, chatSessionId]);

      useEffect(() => {
        if (!chatBoxRef.current) return;
        chatBoxRef.current.scrollTop = chatBoxRef.current.scrollHeight;
      }, [messages]);

      useEffect(() => {
        if (!connected || !token) return;

        const proto = window.location.protocol === "https:" ? "wss" : "ws";
        const ws = new WebSocket(`${proto}://${window.location.host}/ws/chat?token=${encodeURIComponent(token)}`);

        ws.onopen = () => setWsState("connected");
        ws.onerror = () => setWsState("error");
        ws.onclose = () => setWsState("closed");

        ws.onmessage = (event) => {
          let payload = null;
          try {
            payload = JSON.parse(event.data);
          } catch (_err) {
            return;
          }

          if (!payload || !payload.type) return;

          if (payload.type === "chat_meta") {
            setLastMeta(payload.meta || null);
            return;
          }

          if (payload.type === "chat_chunk") {
            const chunk = String(payload.chunk || "");
            setMessages((prev) => prev.map((item) => {
              if (item.id !== activeMsgIdRef.current) return item;
              return { ...item, text: (item.text || "") + chunk };
            }));
            return;
          }

          if (payload.type === "chat") {
            const text = String(payload?.message?.text || "");
            updateAssistantStream(text, true, payload.meta || null);
            setLastMeta(payload.meta || null);
            setStreaming(false);
            activeMsgIdRef.current = null;
            return;
          }

          if (payload.type === "error") {
            updateAssistantStream(`error: ${payload.detail || "unknown"}`, true, null);
            setStreaming(false);
            activeMsgIdRef.current = null;
          }
        };

        wsRef.current = ws;
        return () => {
          ws.close();
          wsRef.current = null;
        };
      }, [connected, token, updateAssistantStream]);

      const sendMessage = useCallback(() => {
        const text = input.trim();
        if (!text || !connected) return;
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
        if (streaming) return;

        const now = Date.now();
        appendMessage({
          id: `u-${now}`,
          role: "user",
          text,
          ts: new Date().toISOString(),
          streaming: false,
        });

        const assistantId = `a-${now}`;
        activeMsgIdRef.current = assistantId;
        appendMessage({
          id: assistantId,
          role: "assistant",
          text: "",
          ts: new Date().toISOString(),
          streaming: true,
        });

        wsRef.current.send(JSON.stringify({ type: "chat", session_id: chatSessionId || "dashboard", text }));
        setStreaming(true);
        setInput("");
      }, [input, connected, streaming, appendMessage, chatSessionId]);

      if (!connected) {
        return <div className="empty">Connect to gateway to open chat.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Gateway Chat</h2>
            <div className="row">
              <span className={`badge ${wsState === "connected" ? "ok" : wsState === "error" ? "err" : "warn"}`}>{wsState}</span>
              <button className="btn" onClick={loadHistory}>Load session history</button>
            </div>
          </div>

          <div className="row">
            <div style={{ minWidth: 120 }} className="muted">Session ID</div>
            <input
              value={chatSessionId}
              onChange={(e) => setChatSessionId(e.target.value)}
              className="mono"
              placeholder="dashboard-session"
            />
          </div>

          <div className="chat-box" ref={chatBoxRef}>
            {messages.length === 0 ? (
              <div className="empty">No messages yet.</div>
            ) : messages.map((msg) => (
              <div key={msg.id} className={`chat-msg ${msg.role === "assistant" ? "assistant" : msg.role === "user" ? "user" : "system"}`}>
                <div>{msg.text || (msg.streaming ? "..." : "")}</div>
                <div className="chat-meta">{msg.role} {msg.streaming ? "(streaming)" : ""} {msg.ts ? `- ${formatTime(msg.ts)}` : ""}</div>
              </div>
            ))}
          </div>

          <div className="row">
            <textarea
              style={{ minHeight: 74, fontFamily: "var(--sans)", fontSize: 13 }}
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Type a message"
            />
          </div>

          <div className="row-between">
            <div className="muted mono" style={{ fontSize: 11 }}>
              {lastMeta ? `mode=${lastMeta.mode || "?"} reason=${lastMeta.reason || "?"} model=${lastMeta.model || "?"}` : "No metadata yet"}
            </div>
            <button className="btn btn-primary" onClick={sendMessage} disabled={!input.trim() || streaming || wsState !== "connected"}>Send</button>
          </div>
        </div>
      );
    }

    function SessionsTab({ connected, apiCall, onUseSession }) {
      const [query, setQuery] = useState("");
      const [loading, setLoading] = useState(false);
      const [sessions, setSessions] = useState([]);
      const [selected, setSelected] = useState("");
      const [messages, setMessages] = useState([]);

      const loadSessions = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const data = await apiCall(`/api/dashboard/sessions?q=${encodeURIComponent(query)}`);
          setSessions(data.sessions || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall, query]);

      const loadSessionMessages = useCallback(async (sessionId) => {
        if (!connected || !sessionId) return;
        const data = await apiCall(`/api/dashboard/sessions/${encodeURIComponent(sessionId)}`);
        setSelected(sessionId);
        setMessages(data.messages || []);
      }, [connected, apiCall]);

      useEffect(() => {
        loadSessions();
      }, [loadSessions]);

      if (!connected) {
        return <div className="empty">Connect to gateway to inspect sessions.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Sessions</h2>
            <div className="row" style={{ flex: 1, justifyContent: "flex-end" }}>
              <input
                style={{ maxWidth: 320 }}
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Search session id or preview"
              />
              <button className="btn" onClick={loadSessions} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
            </div>
          </div>

          <div className="grid grid-2">
            <div className="card" style={{ minHeight: 320 }}>
              <h3>Session Index</h3>
              {sessions.length === 0 ? (
                <div className="empty">No sessions found.</div>
              ) : (
                <div className="stack">
                  {sessions.map((row) => (
                    <div key={row.session_id} className="card" style={{ background: "rgba(10,18,38,0.65)" }}>
                      <div className="row-between">
                        <div>
                          <div className="mono" style={{ fontSize: 12 }}>{row.session_id}</div>
                          <div className="muted" style={{ fontSize: 11 }}>{row.messages || 0} messages - {formatTime(row.last_ts)}</div>
                        </div>
                        <div className="row">
                          <button className="btn" onClick={() => loadSessionMessages(row.session_id)}>Open</button>
                          <button className="btn" onClick={() => onUseSession(row.session_id)}>Use in chat</button>
                        </div>
                      </div>
                      <div className="muted" style={{ marginTop: 6 }}>{clampText(row.preview || "", 160)}</div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            <div className="card" style={{ minHeight: 320 }}>
              <h3>Messages {selected ? `(${selected})` : ""}</h3>
              {messages.length === 0 ? (
                <div className="empty">Select a session to inspect messages.</div>
              ) : (
                <div className="chat-box" style={{ maxHeight: 520 }}>
                  {messages.map((msg, idx) => (
                    <div key={`${msg.ts || idx}-${idx}`} className={`chat-msg ${msg.role === "assistant" ? "assistant" : "user"}`}>
                      <div>{msg.text || ""}</div>
                      <div className="chat-meta">{msg.role} - {formatTime(msg.ts)}</div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    function TelemetryTab({ connected, apiCall }) {
      const [period, setPeriod] = useState("7d");
      const [sessionId, setSessionId] = useState("");
      const [loading, setLoading] = useState(false);
      const [payload, setPayload] = useState(null);

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const q = new URLSearchParams({ period, session_id: sessionId }).toString();
          const data = await apiCall(`/api/dashboard/telemetry?${q}`);
          setPayload(data);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall, period, sessionId]);

      useEffect(() => {
        load();
      }, [load]);

      if (!connected) {
        return <div className="empty">Connect to gateway to inspect telemetry.</div>;
      }

      const summary = payload?.summary || {};
      const sessions = payload?.sessions || [];
      const timeline = payload?.timeline || [];
      const events = payload?.events || [];

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Telemetry</h2>
            <div className="row">
              <select value={period} onChange={(e) => setPeriod(e.target.value)}>
                <option value="24h">24h</option>
                <option value="7d">7d</option>
                <option value="30d">30d</option>
                <option value="all">all</option>
              </select>
              <input value={sessionId} onChange={(e) => setSessionId(e.target.value)} placeholder="optional session_id" className="mono" />
              <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
            </div>
          </div>

          <div className="grid grid-4">
            <div className="kpi"><div className="k">Events</div><div className="v">{summary.events || 0}</div></div>
            <div className="kpi"><div className="k">Sessions</div><div className="v">{summary.sessions || 0}</div></div>
            <div className="kpi"><div className="k">Tokens</div><div className="v">{(summary.tokens || 0).toLocaleString()}</div></div>
            <div className="kpi"><div className="k">Cost (USD)</div><div className="v">${Number(summary.cost_usd || 0).toFixed(6)}</div></div>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Top Sessions</h3>
              {sessions.length === 0 ? <div className="empty">No telemetry sessions in filter.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead>
                      <tr>
                        <th>Session</th>
                        <th>Events</th>
                        <th>Tokens</th>
                        <th>Cost</th>
                        <th>Last</th>
                      </tr>
                    </thead>
                    <tbody>
                      {sessions.slice(0, 60).map((row) => (
                        <tr key={row.session_id}>
                          <td className="mono">{row.session_id}</td>
                          <td>{row.events}</td>
                          <td>{(row.tokens || 0).toLocaleString()}</td>
                          <td>${Number(row.cost_usd || 0).toFixed(6)}</td>
                          <td>{formatTime(row.last_ts)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>

            <div className="card">
              <h3>Timeline</h3>
              {timeline.length === 0 ? <div className="empty">No timeline points.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead>
                      <tr>
                        <th>Bucket</th>
                        <th>Events</th>
                        <th>Tokens</th>
                        <th>Cost</th>
                      </tr>
                    </thead>
                    <tbody>
                      {timeline.map((row) => (
                        <tr key={row.bucket}>
                          <td className="mono">{row.bucket}</td>
                          <td>{row.events}</td>
                          <td>{(row.tokens || 0).toLocaleString()}</td>
                          <td>${Number(row.cost_usd || 0).toFixed(6)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>

          <div className="card">
            <h3>Recent Events</h3>
            {events.length === 0 ? <div className="empty">No events for this filter.</div> : (
              <div className="table-wrap">
                <table>
                  <thead>
                    <tr>
                      <th>ts</th>
                      <th>session</th>
                      <th>model</th>
                      <th>tokens</th>
                      <th>cost</th>
                      <th>mode</th>
                    </tr>
                  </thead>
                  <tbody>
                    {events.map((row, idx) => (
                      <tr key={`${row.ts || ""}-${idx}`}>
                        <td className="mono">{formatTime(row.ts)}</td>
                        <td className="mono">{row.session_id || "-"}</td>
                        <td className="mono">{row.model_effective || row.model_requested || "-"}</td>
                        <td>{(row.tokens || 0).toLocaleString()}</td>
                        <td>${Number(row.cost_usd || 0).toFixed(6)}</td>
                        <td>{row.mode || "-"}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      );
    }

    function ChannelsTab({ connected, apiCall, notify }) {
      const [loading, setLoading] = useState(false);
      const [channels, setChannels] = useState([]);
      const [instances, setInstances] = useState([]);
      const [pending, setPending] = useState([]);
      const [approved, setApproved] = useState([]);

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const [a, b, c, d] = await Promise.all([
            apiCall("/api/channels/status"),
            apiCall("/api/channels/instances"),
            apiCall("/api/pairing/pending"),
            apiCall("/api/pairing/approved"),
          ]);
          setChannels(a.channels || []);
          setInstances(b.instances || []);
          setPending(c.pending || []);
          setApproved(d.approved || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      const reconnect = async (channel) => {
        try {
          await apiCall("/api/channels/reconnect", { method: "POST", body: JSON.stringify({ channel }) });
          notify(`Reconnect requested for ${channel}`, "ok");
          load();
        } catch (err) {
          notify(`Reconnect failed: ${normalizeError(err)}`, "err");
        }
      };

      const approve = async (channel, code, accepted) => {
        const path = accepted ? "/api/pairing/approve" : "/api/pairing/reject";
        try {
          await apiCall(path, { method: "POST", body: JSON.stringify({ channel, code }) });
          notify(`${accepted ? "Approved" : "Rejected"} ${code}`, "ok");
          load();
        } catch (err) {
          notify(`Pairing update failed: ${normalizeError(err)}`, "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to inspect channels.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Channels</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Channel status</h3>
              <div className="table-wrap">
                <table>
                  <thead>
                    <tr>
                      <th>Channel</th>
                      <th>Enabled</th>
                      <th>Configured</th>
                      <th>Instances</th>
                      <th>Sent OK</th>
                      <th>Retries</th>
                      <th>Timeouts</th>
                      <th>Fallbacks</th>
                      <th>Failures</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {channels.map((row) => (
                      <tr key={row.channel}>
                        <td className="mono">{row.channel}</td>
                        <td>{row.enabled ? <span className="badge ok">yes</span> : <span className="badge err">no</span>}</td>
                        <td>{row.configured ? <span className="badge ok">yes</span> : <span className="badge warn">partial</span>}</td>
                        <td>{row.instances_online ?? 0}</td>
                        <td>{row.outbound?.sent_ok ?? 0}</td>
                        <td>{row.outbound?.retry_count ?? 0}</td>
                        <td>{row.outbound?.timeout_count ?? 0}</td>
                        <td>{row.outbound?.fallback_count ?? 0}</td>
                        <td>{row.outbound?.send_fail_count ?? 0}</td>
                        <td><button className="btn" onClick={() => reconnect(row.channel)}>Reconnect</button></td>
                      </tr>
                    ))}
                    {channels.length === 0 && <tr><td colSpan="10" className="muted">No channels configured.</td></tr>}
                  </tbody>
                </table>
              </div>
            </div>

            <div className="card">
              <h3>Active instances</h3>
              <div className="table-wrap">
                <table>
                  <thead>
                    <tr>
                      <th>Instance</th>
                      <th>Channel</th>
                      <th>Account</th>
                      <th>Running</th>
                    </tr>
                  </thead>
                  <tbody>
                    {instances.map((row) => (
                      <tr key={row.instance_key}>
                        <td className="mono">{row.instance_key}</td>
                        <td>{row.channel}</td>
                        <td className="mono">{row.account || "-"}</td>
                        <td>{row.running ? <span className="badge ok">online</span> : <span className="badge err">offline</span>}</td>
                      </tr>
                    ))}
                    {instances.length === 0 && <tr><td colSpan="4" className="muted">No running instances.</td></tr>}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Pending pairing</h3>
              {pending.length === 0 ? <div className="empty">No pending requests.</div> : (
                <div className="stack">
                  {pending.map((row) => (
                    <div className="card" key={`${row.channel}-${row.code}`} style={{ background: "rgba(10,18,38,0.65)" }}>
                      <div className="row-between">
                        <div>
                          <div className="mono">{row.channel} / {row.code}</div>
                          <div className="muted">peer: {row.peer_id}{row.display ? ` (${row.display})` : ""}</div>
                        </div>
                        <div className="row">
                          <button className="btn btn-success" onClick={() => approve(row.channel, row.code, true)}>Approve</button>
                          <button className="btn btn-danger" onClick={() => approve(row.channel, row.code, false)}>Reject</button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            <div className="card">
              <h3>Approved pairing</h3>
              {approved.length === 0 ? <div className="empty">No approved peers.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead>
                      <tr>
                        <th>Channel</th>
                        <th>Peer</th>
                        <th>Display</th>
                        <th>Approved at</th>
                      </tr>
                    </thead>
                    <tbody>
                      {approved.map((row, idx) => (
                        <tr key={`${row.channel}-${row.peer_id}-${idx}`}>
                          <td>{row.channel}</td>
                          <td className="mono">{row.peer_id}</td>
                          <td>{row.display || "-"}</td>
                          <td>{formatTime(row.approved_at)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    function CronTab({ connected, apiCall, notify }) {
      const [jobs, setJobs] = useState([]);
      const [loading, setLoading] = useState(false);
      const [form, setForm] = useState({
        channel: "telegram",
        chat_id: "",
        thread_id: "",
        label: "default",
        name: "",
        text: "",
        interval_seconds: "3600",
        enabled: true,
      });

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const data = await apiCall("/api/cron");
          setJobs(data.jobs || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      const addJob = async () => {
        try {
          await apiCall("/api/cron", {
            method: "POST",
            body: JSON.stringify({
              ...form,
              interval_seconds: Number(form.interval_seconds || 0),
              enabled: Boolean(form.enabled),
            }),
          });
          notify("Cron job saved", "ok");
          setForm((prev) => ({ ...prev, name: "", text: "" }));
          load();
        } catch (err) {
          notify(`Cron save failed: ${normalizeError(err)}`, "err");
        }
      };

      const removeJob = async (jobId) => {
        if (!window.confirm(`Remove cron job ${jobId}?`)) return;
        try {
          await apiCall(`/api/cron/${jobId}`, { method: "DELETE" });
          notify(`Cron job ${jobId} removed`, "ok");
          load();
        } catch (err) {
          notify(`Cron remove failed: ${normalizeError(err)}`, "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to manage cron jobs.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Cron jobs</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="card">
            <h3>Create / Update job</h3>
            <div className="grid grid-3">
              <div><label className="label">channel</label><input value={form.channel} onChange={(e) => setForm({ ...form, channel: e.target.value })} /></div>
              <div><label className="label">chat_id</label><input value={form.chat_id} onChange={(e) => setForm({ ...form, chat_id: e.target.value })} /></div>
              <div><label className="label">thread_id</label><input value={form.thread_id} onChange={(e) => setForm({ ...form, thread_id: e.target.value })} /></div>
              <div><label className="label">label</label><input value={form.label} onChange={(e) => setForm({ ...form, label: e.target.value })} /></div>
              <div><label className="label">name</label><input value={form.name} onChange={(e) => setForm({ ...form, name: e.target.value })} /></div>
              <div><label className="label">interval_seconds</label><input value={form.interval_seconds} onChange={(e) => setForm({ ...form, interval_seconds: e.target.value })} /></div>
            </div>
            <div style={{ marginTop: 10 }}>
              <label className="label">text</label>
              <textarea value={form.text} onChange={(e) => setForm({ ...form, text: e.target.value })} />
            </div>
            <div className="row" style={{ marginTop: 10 }}>
              <label className="row" style={{ fontSize: 13 }}>
                <input type="checkbox" checked={form.enabled} onChange={(e) => setForm({ ...form, enabled: e.target.checked })} style={{ width: 16 }} />
                enabled
              </label>
              <button className="btn btn-primary" onClick={addJob}>Save cron job</button>
            </div>
          </div>

          <div className="card">
            <h3>Current jobs</h3>
            <div className="table-wrap">
              <table>
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>channel</th>
                    <th>chat</th>
                    <th>thread</th>
                    <th>label</th>
                    <th>name</th>
                    <th>interval</th>
                    <th>enabled</th>
                    <th>next_run</th>
                    <th>last_result</th>
                    <th>actions</th>
                  </tr>
                </thead>
                <tbody>
                  {jobs.map((row) => (
                    <tr key={row.id}>
                      <td>{row.id}</td>
                      <td>{row.channel}</td>
                      <td className="mono">{row.chat_id}</td>
                      <td className="mono">{row.thread_id || "-"}</td>
                      <td>{row.label}</td>
                      <td>{row.name}</td>
                      <td>{row.interval_seconds}</td>
                      <td>{Number(row.enabled) ? "yes" : "no"}</td>
                      <td>{row.next_run_at ? formatTime(Number(row.next_run_at) * 1000) : "-"}</td>
                      <td>{clampText(row.last_result || "", 60)}</td>
                      <td><button className="btn btn-danger" onClick={() => removeJob(row.id)}>Remove</button></td>
                    </tr>
                  ))}
                  {jobs.length === 0 && <tr><td colSpan="11" className="muted">No cron jobs.</td></tr>}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    }

    function ConfigTab({ connected, apiCall, notify }) {
      const [loading, setLoading] = useState(false);
      const [models, setModels] = useState([]);
      const [model, setModel] = useState("");
      const [hooksPre, setHooksPre] = useState("");
      const [hooksPost, setHooksPost] = useState("");
      const [theme, setTheme] = useState("dark");
      const [channelsText, setChannelsText] = useState("{}");
      const [catalogProvider, setCatalogProvider] = useState("");

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const [settingsRes, modelsRes] = await Promise.all([
            apiCall("/api/dashboard/settings"),
            apiCall(`/api/models/catalog?provider=${encodeURIComponent(catalogProvider)}`),
          ]);
          const settings = settingsRes.settings || {};
          setModel(settings.model || "");
          setHooksPre(settings.hooks?.pre || "");
          setHooksPost(settings.hooks?.post || "");
          setTheme(settings.theme || "dark");
          setChannelsText(prettyJSON(settings.channels || {}));
          setModels(modelsRes.models || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall, catalogProvider]);

      useEffect(() => {
        load();
      }, [load]);

      const parseChannels = () => {
        try {
          const parsed = JSON.parse(channelsText || "{}");
          if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
            throw new Error("channels must be a JSON object");
          }
          return parsed;
        } catch (err) {
          throw new Error(`Invalid channels JSON: ${normalizeError(err)}`);
        }
      };

      const saveSettings = async () => {
        try {
          const channels = parseChannels();
          await apiCall("/api/dashboard/settings", {
            method: "PUT",
            body: JSON.stringify({
              model,
              channels,
              hooks: { pre: hooksPre, post: hooksPost },
              theme,
            }),
          });
          notify("Settings saved", "ok");
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      const applyConfig = async (dryRun) => {
        try {
          const channels = parseChannels();
          const res = await apiCall("/api/dashboard/config/apply", {
            method: "POST",
            body: JSON.stringify({ model, channels, dry_run: dryRun }),
          });
          notify(res.message || (dryRun ? "Dry-run validated" : "Config applied"), "ok");
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      const restartGateway = async () => {
        try {
          const res = await apiCall("/api/dashboard/config/restart", { method: "POST", body: JSON.stringify({ mode: "safe" }) });
          notify(res.message || "Restart request sent", "ok");
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to manage config.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Gateway config</h2>
            <div className="row">
              <input style={{ width: 160 }} value={catalogProvider} onChange={(e) => setCatalogProvider(e.target.value)} placeholder="provider filter" />
              <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
            </div>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Model and hooks</h3>
              <div className="stack">
                <div>
                  <label className="label">model</label>
                  <select value={model} onChange={(e) => setModel(e.target.value)}>
                    <option value="">Select model</option>
                    {models.map((item) => (
                      <option key={item.key} value={item.key}>{item.key}{item.deprecated ? " [deprecated]" : ""}</option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="label">hook pre</label>
                  <textarea value={hooksPre} onChange={(e) => setHooksPre(e.target.value)} />
                </div>
                <div>
                  <label className="label">hook post</label>
                  <textarea value={hooksPost} onChange={(e) => setHooksPost(e.target.value)} />
                </div>
                <div>
                  <label className="label">theme</label>
                  <select value={theme} onChange={(e) => setTheme(e.target.value)}>
                    <option value="dark">dark</option>
                    <option value="light">light</option>
                  </select>
                </div>
              </div>
            </div>

            <div className="card">
              <h3>Channel JSON</h3>
              <textarea className="editor" value={channelsText} onChange={(e) => setChannelsText(e.target.value)} />
            </div>
          </div>

          <div className="row">
            <button className="btn btn-primary" onClick={saveSettings}>Save settings</button>
            <button className="btn" onClick={() => applyConfig(true)}>Validate (dry-run)</button>
            <button className="btn btn-success" onClick={() => applyConfig(false)}>Apply config</button>
            <button className="btn" onClick={restartGateway}>Register safe restart</button>
          </div>
        </div>
      );
    }

    function WorkspaceTab({ connected, apiCall, notify }) {
      const [name, setName] = useState(WORKSPACE_FILES[0]);
      const [content, setContent] = useState("");
      const [loading, setLoading] = useState(false);

      const load = useCallback(async (target = name) => {
        if (!connected) return;
        setLoading(true);
        try {
          const data = await apiCall(`/api/workspace/file?name=${encodeURIComponent(target)}`);
          setContent(data.content || "");
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall, name]);

      useEffect(() => {
        load(name);
      }, [load, name]);

      const save = async () => {
        try {
          const res = await apiCall("/api/workspace/file", {
            method: "PUT",
            body: JSON.stringify({ name, content }),
          });
          notify(`Saved ${res.name} (${res.bytes} bytes)`, "ok");
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to edit workspace files.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Workspace editor</h2>
            <div className="row">
              <select value={name} onChange={(e) => setName(e.target.value)}>
                {WORKSPACE_FILES.map((f) => <option key={f} value={f}>{f}</option>)}
              </select>
              <button className="btn" onClick={() => load(name)} disabled={loading}>{loading ? "Loading..." : "Reload"}</button>
              <button className="btn btn-primary" onClick={save}>Save</button>
            </div>
          </div>
          <textarea className="editor" value={content} onChange={(e) => setContent(e.target.value)} />
        </div>
      );
    }

    function SkillsTab({ connected, apiCall, notify }) {
      const [loading, setLoading] = useState(false);
      const [skills, setSkills] = useState([]);
      const [hubSkills, setHubSkills] = useState([]);
      const [slug, setSlug] = useState("");
      const [selected, setSelected] = useState(new Set());

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const [localRes, hubRes] = await Promise.all([
            apiCall("/api/dashboard/skills"),
            fetch("/api/hub/manifest").then((r) => r.json()).catch(() => ({ ok: false })),
          ]);
          setSkills(localRes.skills || []);
          setHubSkills(hubRes?.manifest?.skills || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      const install = async () => {
        const clean = slug.trim();
        if (!clean) return;
        try {
          await apiCall("/api/dashboard/skills/install", { method: "POST", body: JSON.stringify({ slug: clean }) });
          notify(`Installed ${clean}`, "ok");
          setSlug("");
          load();
        } catch (err) {
          notify(`Install failed: ${normalizeError(err)}`, "err");
        }
      };

      const toggle = async (name, enabled) => {
        const path = enabled ? "/api/dashboard/skills/disable" : "/api/dashboard/skills/enable";
        try {
          await apiCall(path, { method: "POST", body: JSON.stringify({ slug: name }) });
          notify(`${enabled ? "Disabled" : "Enabled"} ${name}`, "ok");
          load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      const removeSkill = async (name) => {
        if (!window.confirm(`Remove skill ${name}?`)) return;
        try {
          await apiCall("/api/dashboard/skills/remove", { method: "POST", body: JSON.stringify({ slug: name }) });
          notify(`Removed ${name}`, "ok");
          load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      const runUpdate = async (dryRun) => {
        try {
          const slugs = Array.from(selected);
          const res = await apiCall("/api/dashboard/update", {
            method: "POST",
            body: JSON.stringify({ slugs, dry_run: dryRun }),
          });
          const changed = (res?.result?.updated || []).length;
          notify(`${dryRun ? "Dry-run" : "Update"} done (${changed} updated)`, "ok");
          if (!dryRun) load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to manage skills.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Skills</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="row">
            <input value={slug} onChange={(e) => setSlug(e.target.value)} placeholder="skill slug (example: github)" />
            <button className="btn btn-primary" onClick={install}>Install</button>
            <button className="btn" onClick={() => runUpdate(true)}>Update dry-run</button>
            <button className="btn btn-success" onClick={() => runUpdate(false)}>Apply update</button>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Local skills</h3>
              {skills.length === 0 ? <div className="empty">No local skills.</div> : (
                <div className="stack">
                  {skills.map((row) => (
                    <div key={row.slug} className="row-between card" style={{ background: "rgba(10,18,38,0.65)" }}>
                      <label className="row" style={{ margin: 0 }}>
                        <input
                          style={{ width: 14 }}
                          type="checkbox"
                          checked={selected.has(row.slug)}
                          onChange={(e) => {
                            setSelected((prev) => {
                              const next = new Set(prev);
                              if (e.target.checked) next.add(row.slug);
                              else next.delete(row.slug);
                              return next;
                            });
                          }}
                        />
                        <span className="mono">{row.slug}</span>
                        <span className={`badge ${row.enabled ? "ok" : "warn"}`}>{row.enabled ? "enabled" : "disabled"}</span>
                      </label>
                      <div className="row">
                        <button className="btn" onClick={() => toggle(row.slug, row.enabled)}>{row.enabled ? "Disable" : "Enable"}</button>
                        <button className="btn btn-danger" onClick={() => removeSkill(row.slug)}>Remove</button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            <div className="card">
              <h3>Hub manifest</h3>
              {hubSkills.length === 0 ? <div className="empty">Hub manifest not available.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead>
                      <tr>
                        <th>slug</th>
                        <th>version</th>
                        <th>description</th>
                        <th>downloads</th>
                      </tr>
                    </thead>
                    <tbody>
                      {hubSkills.slice(0, 120).map((row, idx) => (
                        <tr key={`${row.slug || ""}-${idx}`}>
                          <td className="mono">{row.slug || "-"}</td>
                          <td>{row.version || "-"}</td>
                          <td>{clampText(row.description || "", 120)}</td>
                          <td>{row.downloads || row.download_count || 0}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    function AgentsTab({ connected, apiCall, notify }) {
      const [agents, setAgents] = useState([]);
      const [bindings, setBindings] = useState([]);
      const [loading, setLoading] = useState(false);
      const [createForm, setCreateForm] = useState({
        name: "",
        channel: "telegram",
        role: "",
        personality: "",
        token: "",
        account: "",
        orchestrator: false,
        tags: "",
      });
      const [bindForm, setBindForm] = useState({ agent: "", channel: "telegram", account: "" });

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const data = await apiCall("/api/agents");
          setAgents(data.agents || []);
          setBindings(data.bindings || []);
          setBindForm((prev) => ({ ...prev, agent: prev.agent || ((data.agents || [])[0]?.id || "") }));
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      const createAgent = async () => {
        try {
          await apiCall("/api/agents", {
            method: "POST",
            body: JSON.stringify({
              ...createForm,
              tags: createForm.tags.split(",").map((x) => x.trim()).filter(Boolean),
            }),
          });
          notify("Agent created", "ok");
          setCreateForm((prev) => ({ ...prev, name: "", role: "", personality: "", token: "", account: "", tags: "" }));
          load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      const bindAgent = async () => {
        try {
          await apiCall("/api/agents/bind", {
            method: "POST",
            body: JSON.stringify(bindForm),
          });
          notify("Agent binding saved", "ok");
          load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to manage agents.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Agents</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Create agent</h3>
              <div className="grid grid-2">
                <div><label className="label">name</label><input value={createForm.name} onChange={(e) => setCreateForm({ ...createForm, name: e.target.value })} /></div>
                <div><label className="label">channel</label><input value={createForm.channel} onChange={(e) => setCreateForm({ ...createForm, channel: e.target.value })} /></div>
                <div><label className="label">role</label><input value={createForm.role} onChange={(e) => setCreateForm({ ...createForm, role: e.target.value })} /></div>
                <div><label className="label">account</label><input value={createForm.account} onChange={(e) => setCreateForm({ ...createForm, account: e.target.value })} /></div>
              </div>
              <div style={{ marginTop: 8 }}><label className="label">personality</label><textarea value={createForm.personality} onChange={(e) => setCreateForm({ ...createForm, personality: e.target.value })} /></div>
              <div style={{ marginTop: 8 }}><label className="label">token/credentials</label><input className="mono" value={createForm.token} onChange={(e) => setCreateForm({ ...createForm, token: e.target.value })} /></div>
              <div style={{ marginTop: 8 }}><label className="label">tags (comma separated)</label><input value={createForm.tags} onChange={(e) => setCreateForm({ ...createForm, tags: e.target.value })} /></div>
              <div className="row" style={{ marginTop: 10 }}>
                <label className="row" style={{ margin: 0 }}>
                  <input style={{ width: 14 }} type="checkbox" checked={createForm.orchestrator} onChange={(e) => setCreateForm({ ...createForm, orchestrator: e.target.checked })} />
                  orchestrator
                </label>
                <button className="btn btn-primary" onClick={createAgent}>Create</button>
              </div>
            </div>

            <div className="card">
              <h3>Bind agent</h3>
              <div className="stack">
                <div>
                  <label className="label">agent</label>
                  <select value={bindForm.agent} onChange={(e) => setBindForm({ ...bindForm, agent: e.target.value })}>
                    <option value="">Select agent</option>
                    {agents.map((a) => <option key={a.id} value={a.id}>{a.id} - {a.name || a.id}</option>)}
                  </select>
                </div>
                <div><label className="label">channel</label><input value={bindForm.channel} onChange={(e) => setBindForm({ ...bindForm, channel: e.target.value })} /></div>
                <div><label className="label">account</label><input value={bindForm.account} onChange={(e) => setBindForm({ ...bindForm, account: e.target.value })} /></div>
                <button className="btn btn-primary" onClick={bindAgent}>Bind</button>
              </div>
            </div>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Agent list</h3>
              {agents.length === 0 ? <div className="empty">No agents.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead><tr><th>id</th><th>name</th><th>channel</th><th>role</th><th>orchestrator</th></tr></thead>
                    <tbody>
                      {agents.map((a) => (
                        <tr key={a.id}>
                          <td className="mono">{a.id}</td>
                          <td>{a.name || "-"}</td>
                          <td>{a.channel || "-"}</td>
                          <td>{a.role || "-"}</td>
                          <td>{a.orchestrator ? "yes" : "no"}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>

            <div className="card">
              <h3>Bindings</h3>
              {bindings.length === 0 ? <div className="empty">No bindings.</div> : (
                <div className="table-wrap">
                  <table>
                    <thead><tr><th>agent</th><th>channel</th><th>account</th><th>created</th></tr></thead>
                    <tbody>
                      {bindings.map((b, idx) => (
                        <tr key={`${b.agent_id || ""}-${b.channel || ""}-${idx}`}>
                          <td className="mono">{b.agent_id || b.agent || "-"}</td>
                          <td>{b.channel || "-"}</td>
                          <td className="mono">{b.account || "-"}</td>
                          <td>{formatTime(b.created_at)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    function LogsTab({ connected, token, apiCall }) {
      const [logs, setLogs] = useState([]);
      const [filters, setFilters] = useState({ level: "", event: "", q: "" });
      const [wsState, setWsState] = useState("disconnected");
      const wsRef = useRef(null);

      const loadPull = useCallback(async () => {
        if (!connected) return;
        const q = new URLSearchParams({ limit: "200", level: filters.level, event: filters.event, q: filters.q }).toString();
        try {
          const data = await apiCall(`/api/dashboard/logs?${q}`);
          setLogs(data.logs || []);
        } catch (_err) {
          // Keep ws logs if pull fails.
        }
      }, [connected, apiCall, filters]);

      useEffect(() => {
        if (!connected || !token) return;
        const proto = window.location.protocol === "https:" ? "wss" : "ws";
        const ws = new WebSocket(`${proto}://${window.location.host}/ws/logs?token=${encodeURIComponent(token)}`);
        ws.onopen = () => {
          setWsState("connected");
          ws.send(JSON.stringify({ type: "filters", ...filters }));
        };
        ws.onerror = () => setWsState("error");
        ws.onclose = () => setWsState("closed");
        ws.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            if (payload.type === "snapshot") {
              setLogs(payload.logs || []);
            }
          } catch (_err) {
            // Ignore malformed frames.
          }
        };
        wsRef.current = ws;
        return () => {
          ws.close();
          wsRef.current = null;
        };
      }, [connected, token]);

      useEffect(() => {
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
        wsRef.current.send(JSON.stringify({ type: "filters", ...filters }));
      }, [filters]);

      if (!connected) {
        return <div className="empty">Connect to gateway to stream logs.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Logs</h2>
            <div className="row">
              <span className={`badge ${wsState === "connected" ? "ok" : wsState === "error" ? "err" : "warn"}`}>{wsState}</span>
              <button className="btn" onClick={loadPull}>Pull once</button>
            </div>
          </div>

          <div className="row">
            <input value={filters.level} onChange={(e) => setFilters({ ...filters, level: e.target.value })} placeholder="level (info|warn|error)" />
            <input value={filters.event} onChange={(e) => setFilters({ ...filters, event: e.target.value })} placeholder="event" />
            <input value={filters.q} onChange={(e) => setFilters({ ...filters, q: e.target.value })} placeholder="query" />
          </div>

          <div className="table-wrap" style={{ maxHeight: "72vh" }}>
            <table>
              <thead>
                <tr>
                  <th>ts</th>
                  <th>level</th>
                  <th>event</th>
                  <th>data</th>
                </tr>
              </thead>
              <tbody>
                {logs.map((row, idx) => (
                  <tr key={`${row.ts || ""}-${idx}`}>
                    <td className="mono">{formatTime(row.ts)}</td>
                    <td>{row.level}</td>
                    <td className="mono">{row.event}</td>
                    <td className="mono">{clampText(prettyJSON(row.data || {}), 240)}</td>
                  </tr>
                ))}
                {logs.length === 0 && <tr><td colSpan="4" className="muted">No logs in snapshot.</td></tr>}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function SecurityTab({ connected, apiCall, notify }) {
      const [loading, setLoading] = useState(false);
      const [rbac, setRbac] = useState(null);
      const [audit, setAudit] = useState([]);
      const [toolName, setToolName] = useState("");
      const [policy, setPolicy] = useState("review");

      const load = useCallback(async () => {
        if (!connected) return;
        setLoading(true);
        try {
          const [rolesRes, auditRes] = await Promise.all([
            apiCall("/api/security/rbac"),
            apiCall("/api/security/tool-audit?limit=150"),
          ]);
          setRbac(rolesRes);
          setAudit(auditRes.entries || []);
        } finally {
          setLoading(false);
        }
      }, [connected, apiCall]);

      useEffect(() => {
        load();
      }, [load]);

      const setToolPolicy = async () => {
        if (!toolName.trim()) {
          notify("tool_name is required", "err");
          return;
        }
        try {
          await apiCall("/api/security/tool-policy", {
            method: "PUT",
            body: JSON.stringify({ tool_name: toolName.trim(), policy }),
          });
          notify(`Policy set: ${toolName} -> ${policy}`, "ok");
          load();
        } catch (err) {
          notify(normalizeError(err), "err");
        }
      };

      if (!connected) {
        return <div className="empty">Connect to gateway to inspect security state.</div>;
      }

      return (
        <div className="stack">
          <div className="row-between">
            <h2 style={{ margin: 0, fontSize: 16 }}>Security</h2>
            <button className="btn" onClick={load} disabled={loading}>{loading ? "Loading..." : "Refresh"}</button>
          </div>

          <div className="grid grid-2">
            <div className="card">
              <h3>Tool policy</h3>
              <div className="row">
                <input value={toolName} onChange={(e) => setToolName(e.target.value)} placeholder="tool_name" />
                <select value={policy} onChange={(e) => setPolicy(e.target.value)}>
                  <option value="allow">allow</option>
                  <option value="review">review</option>
                  <option value="deny">deny</option>
                </select>
                <button className="btn btn-primary" onClick={setToolPolicy}>Apply</button>
              </div>
              <div className="table-wrap" style={{ marginTop: 10 }}>
                <table>
                  <thead><tr><th>tool</th><th>policy</th></tr></thead>
                  <tbody>
                    {Object.entries(rbac?.tool_policies || {}).map(([name, p]) => (
                      <tr key={name}><td className="mono">{name}</td><td>{String(p)}</td></tr>
                    ))}
                    {Object.keys(rbac?.tool_policies || {}).length === 0 && <tr><td colSpan="2" className="muted">No explicit tool policies.</td></tr>}
                  </tbody>
                </table>
              </div>
            </div>

            <div className="card">
              <h3>Roles</h3>
              <div className="table-wrap">
                <table>
                  <thead><tr><th>role</th><th>scopes</th></tr></thead>
                  <tbody>
                    {Object.entries(rbac?.roles || {}).map(([role, scopes]) => (
                      <tr key={role}><td>{role}</td><td className="mono">{(scopes || []).join(", ")}</td></tr>
                    ))}
                    {Object.keys(rbac?.roles || {}).length === 0 && <tr><td colSpan="2" className="muted">No role map available.</td></tr>}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div className="card">
            <h3>Tool audit</h3>
            <div className="table-wrap" style={{ maxHeight: "48vh" }}>
              <table>
                <thead>
                  <tr>
                    <th>ts</th>
                    <th>tool</th>
                    <th>policy</th>
                    <th>allowed</th>
                    <th>reason</th>
                  </tr>
                </thead>
                <tbody>
                  {audit.map((row, idx) => (
                    <tr key={`${row.ts || ""}-${idx}`}>
                      <td className="mono">{formatTime(row.ts)}</td>
                      <td className="mono">{row.tool_name || "-"}</td>
                      <td>{row.policy || "-"}</td>
                      <td>{row.allowed ? <span className="badge ok">yes</span> : <span className="badge err">no</span>}</td>
                      <td>{clampText(row.reason || "", 120)}</td>
                    </tr>
                  ))}
                  {audit.length === 0 && <tr><td colSpan="5" className="muted">No tool audit entries.</td></tr>}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    }

    function MainApp() {
      const [tab, setTab] = useState("overview");
      const [token, setToken] = useState("");
      const [connected, setConnected] = useState(false);
      const [connecting, setConnecting] = useState(false);
      const [status, setStatus] = useState(null);
      const [toast, setToast] = useState(null);
      const [chatSessionId, setChatSessionId] = useState("dashboard-session");
      const statusPollRef = useRef(null);

      const notify = useCallback((text, kind = "") => {
        setToast({ text, kind });
      }, []);

      useEffect(() => {
        const hashToken = parseHashToken();
        const localToken = window.localStorage.getItem("clawlite_token") || "";
        const initial = hashToken || localToken;
        if (initial) setToken(initial);
      }, []);

      useEffect(() => {
        if (!toast) return;
        const t = window.setTimeout(() => setToast(null), 3800);
        return () => window.clearTimeout(t);
      }, [toast]);

      const apiCall = useCallback(async (path, options = {}) => {
        const headers = {
          "Content-Type": "application/json",
          ...(options.headers || {}),
        };
        if (token) headers.Authorization = `Bearer ${token}`;

        const res = await fetch(path, {
          ...options,
          headers,
        });

        let data = {};
        try {
          data = await res.json();
        } catch (_err) {
          // Keep fallback empty JSON.
        }

        if (!res.ok) {
          throw new Error(data.detail || `HTTP ${res.status}`);
        }
        return data;
      }, [token]);

      const refreshStatus = useCallback(async () => {
        if (!connected) return;
        try {
          const data = await apiCall("/api/dashboard/status");
          setStatus(data);
        } catch (_err) {
          // status polling failures are non-fatal.
        }
      }, [connected, apiCall]);

      useEffect(() => {
        if (!connected) return;
        refreshStatus();
        if (statusPollRef.current) {
          window.clearInterval(statusPollRef.current);
        }
        statusPollRef.current = window.setInterval(refreshStatus, 12000);
        return () => {
          if (statusPollRef.current) {
            window.clearInterval(statusPollRef.current);
            statusPollRef.current = null;
          }
        };
      }, [connected, refreshStatus]);

      const connect = useCallback(async () => {
        const clean = token.trim();
        if (!clean) {
          notify("Token is required", "err");
          return;
        }

        setConnecting(true);
        try {
          const auth = await fetch("/api/dashboard/auth", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: clean }),
          }).then((r) => r.json());

          if (!auth.ok) {
            throw new Error("Invalid token");
          }

          window.localStorage.setItem("clawlite_token", clean);
          setToken(clean);
          setConnected(true);

          try {
            const boot = await apiCall("/api/dashboard/bootstrap", {
              headers: { Authorization: `Bearer ${clean}` },
            });
            setStatus(boot.status || null);
            setChatSessionId((prev) => prev || "dashboard-session");
          } catch (_err) {
            // If bootstrap fails after auth, keep connection but show warning.
          }

          notify("Connected", "ok");
        } catch (err) {
          setConnected(false);
          notify(`Auth failed: ${normalizeError(err)}`, "err");
        } finally {
          setConnecting(false);
        }
      }, [token, notify, apiCall]);

      useEffect(() => {
        if (!token) return;
        connect();
        // Auto-connect only on first token discovery.
      }, []);

      const disconnect = useCallback(() => {
        setConnected(false);
        setStatus(null);
        notify("Disconnected", "");
      }, [notify]);

      const tabMeta = useMemo(() => TAB_DEFS.find((t) => t.id === tab) || TAB_DEFS[0], [tab]);

      const renderTab = () => {
        if (tab === "overview") {
          return <OverviewTab connected={connected} apiCall={apiCall} />;
        }
        if (tab === "chat") {
          return (
            <ChatTab
              connected={connected}
              token={token}
              apiCall={apiCall}
              chatSessionId={chatSessionId}
              setChatSessionId={setChatSessionId}
            />
          );
        }
        if (tab === "sessions") {
          return (
            <SessionsTab
              connected={connected}
              apiCall={apiCall}
              onUseSession={(sessionId) => {
                setChatSessionId(sessionId);
                setTab("chat");
              }}
            />
          );
        }
        if (tab === "telemetry") {
          return <TelemetryTab connected={connected} apiCall={apiCall} />;
        }
        if (tab === "channels") {
          return <ChannelsTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "cron") {
          return <CronTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "config") {
          return <ConfigTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "workspace") {
          return <WorkspaceTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "skills") {
          return <SkillsTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "agents") {
          return <AgentsTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        if (tab === "logs") {
          return <LogsTab connected={connected} token={token} apiCall={apiCall} />;
        }
        if (tab === "security") {
          return <SecurityTab connected={connected} apiCall={apiCall} notify={notify} />;
        }
        return <div className="empty">Tab not implemented.</div>;
      };

      return (
        <>
          <div className="app">
            <aside className="sidebar">
              <div className="brand">
                <div className="brand-badge">CL</div>
                <div>
                  <h1>ClawLite Control UI</h1>
                  <p>OpenClaw-style dashboard for local gateway operations</p>
                </div>
              </div>

              <div className="card">
                <h2>Auth</h2>
                <label className="label">Gateway token</label>
                <input
                  className="mono"
                  type="password"
                  value={token}
                  onChange={(e) => setToken(e.target.value)}
                  placeholder="Bearer token"
                />
                <div className="auth-actions" style={{ marginTop: 10 }}>
                  <button className="btn btn-primary" onClick={connect} disabled={connecting || !token.trim()}>
                    {connecting ? "Connecting..." : "Connect"}
                  </button>
                  <button className="btn" onClick={disconnect}>Disconnect</button>
                </div>
              </div>

              <div className="card">
                <h2>Status</h2>
                <div className="status-list">
                  <div className="status-row"><span>Connection</span><span className={`status-value ${connected ? "status-ok" : "status-err"}`}>{connected ? "connected" : "offline"}</span></div>
                  <div className="status-row"><span>Model</span><span className="status-value">{status?.model || "-"}</span></div>
                  <div className="status-row"><span>Uptime</span><span className="status-value">{formatUptime(status?.uptime_seconds)}</span></div>
                  <div className="status-row"><span>Connections</span><span className="status-value">{status?.connections ?? 0}</span></div>
                </div>
              </div>

              <div className="card">
                <h2>Navigation</h2>
                <div className="nav">
                  {TAB_DEFS.map((item) => (
                    <button key={item.id} className={tab === item.id ? "active" : ""} onClick={() => setTab(item.id)}>{item.label}</button>
                  ))}
                </div>
              </div>
            </aside>

            <main className="main">
              <header className="main-header">
                <div>
                  <h2 className="main-title">{tabMeta.label}</h2>
                  <p className="main-subtitle">ClawLite dashboard synced with gateway runtime endpoints.</p>
                </div>
                <div className="main-actions">
                  <button className="btn" onClick={refreshStatus}>Refresh status</button>
                  <button className="btn" onClick={() => setTab("chat")}>Open chat</button>
                </div>
              </header>

              <section className="view">
                {renderTab()}
              </section>
            </main>
          </div>

          <Toast item={toast} onClose={() => setToast(null)} />
        </>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<MainApp />);
  </script>
</body>

</html>
